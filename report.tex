  \documentclass[oneside,final,14pt]{extreport}
  \usepackage[utf8]{inputenc}
  \usepackage[russian]{babel}
  \usepackage{vmargin}
  \setpapersize{A4}
  \setmarginsrb{2cm}{1.5cm}{1cm}{1.5cm}{0pt}{0mm}{0pt}{13mm}
  \usepackage{indentfirst}
  \usepackage{amsmath,amssymb}
  
 \usepackage{color}
 \usepackage{listings}
 
 \usepackage{caption}
\DeclareCaptionFont{white}{\color{white}}

\DeclareCaptionFormat{listing}{\colorbox{gray}{\parbox{\textwidth}{#1#2#3}}}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white}
  \sloppy

\clubpenalty=9999
\widowpenalty=9999

\usepackage{graphicx}

\newenvironment{compactlist}{
    \begin{list}{{$\bullet$}}{
      \setlength\partopsep{0pt}
      \setlength\parskip{0pt}
      \setlength\parsep{0pt}
      \setlength\topsep{0pt}
      \setlength\itemsep{0pt}
} }{

 \end{list} 
} 

\begin{document}
\lstset{ %
language=c++,                 % выбор языка для подсветки (здесь это С)
basicstyle=\small\sffamily, % размер и начертание шрифта для подсветки кода
numbers=left,               % где поставить нумерацию строк (слева\справа)
numberstyle=\tiny,           % размер шрифта для номеров строк
stepnumber=1,                   % размер шага между двумя номерами строк
numbersep=5pt,                % как далеко отстоят номера строк от подсвечиваемого кода
backgroundcolor=\color{white}, % цвет фона подсветки - используем \usepackage{color}
showspaces=false,            % показывать или нет пробелы специальными отступами
showstringspaces=false,      % показывать или нет пробелы в строках
showtabs=false,             % показывать или нет табуляцию в строках
frame=single,              % рисовать рамку вокруг кода
tabsize=2,                 % размер табуляции по умолчанию равен 2 пробелам
captionpos=t,              % позиция заголовка вверху [t] или внизу [b] 
breaklines=true,           % автоматически переносить строки (да\нет)
breakatwhitespace=false, % переносить строки только если есть пробел
escapeinside={\%*}{*)}   % если нужно добавить комментарии в коде
}
%**********************************ТИТУЛ***************************

\centerline{ {\bf Московский государственный университет} }
\centerline{{\bf имени М. В. Ломоносова} }

\vspace{\baselineskip}

\centerline{ {\bf Факультет вычислительной математики и кибернетики} }
\centerline{{\bf Кафедра математической кибернетики} }

\vfill
\vfill

\centerline {{\bf ОТЧЕТ ПО ПРЕДДИПЛОМНОЙ ПРАКТИКЕ}}
\centerline {{\bf СТУДЕНТА 418 ГРУППЫ}}

\centerline {{\bf Вороновой Надежды Константиновны}}

\vfill
\vfill

\centerline {{\bf Тема работы}}

\centerline {{\bf СВОЙСТВА \(k\)-ЗНАЧНЫХ ФУНКЦИЙ}}
\centerline {{\bf ДВУХ ПЕРЕМЕННЫХ}}
\normalsize

\vfill
\vfill

\begin{minipage}{0.45\textwidth}
  {\bf Руководитель практики} \\
  {\bf от факультета} \\
  {\bf профессор, д.ф. - м.н.} \\
  {\bf А. А. Вороненко}
\end{minipage}
\hfill
\begin{minipage}{0.4\textwidth}
 {\bf Научный руководитель} \\
 {\bf профессор, д.ф. - м.н.}\\
{\bf А. А. Вороненко }
\end{minipage}


\begin{minipage}{0.45\textwidth}
\hfill             \\
{\bf \underline{ }\underline{ }\underline{ }\underline{ }\underline{ }\underline{ }\underline{ }\underline{ }\underline{ }\underline{ }\underline{ }\underline{ }\underline{ }\underline{ }\underline{ }\underline{ }\underline{ }\underline{ }\underline{ }\underline{ }\underline{ }\underline{ }}
\end{minipage}


\vfill

\centerline {\includegraphics[width=0.4\textwidth]{for_kurs}}

\vfill

\begin{center}
  Москва, 2015
\end{center}

\thispagestyle{empty}

\clearpage
%------------------------------ тут должно быть оглавление-------------------------------------

\tableofcontents

%-------------------------------введение-------------------------------------------------------

  \chapter{Введение}

Задача поиска универсальных функций для класса \(k\)-значных линейных была поставлена в работе \cite{k_lin}.

Постановка задачи.

Найти частично определённую функцию \(F\) в \(k\)-значной логике \(n\) переменных 
для определённого класса функций \(K\) такую, что для любой функции \(g\) из данного класса существует такое
множество наборов \(S \subseteq B_k ^n\), что система уравнений \{\(g(x) = F(x) | g \in K, x \in S\)\} однозначно определяет
функцию \(g\). В случае существования такой функции оценить количество наборов, 
на которых достаточно задать функцию \(F\).

На данный момент рассмотрены случаи:
\begin{compactlist}
\item Для простых \(k > 5\) -- в работе \cite{k_lin} 
\item Для составных \(k\) -- в работах \cite{} и \cite{}
\end{compactlist}

Для составных \(k\) от 4 до 30 вопрос о существовании универсальной функции двух переменных не решен.

%Рассматривается задача порождения ложных образов функций k-значных логики при различных k. 
%\vspace{\baselineskip}
%
%Данная задача сформулирована в работе \cite{k_lin}.\\
%Постановка задачи.
%Найти частично определённую функцию \(F\) в \(k\)-значной логике \(n\) переменных 
%для определённого класса функций \(K\) такую, что для любой функции \(g\) из данного класса существует такое
%множество наборов \(S \subseteq B_k ^n\), что система уравнений \{\(g(x) = F(x) | g \in K, x \in S\)\} однозначно определяет
%функцию \(g\). В случае существования такой функции оценить количество наборов, 
%на которых достаточно задать функцию \(F\).

%Её аналоги были рассмотрены для класса линейных булевых функций в работе \cite{bin_lin} и 
%для класса монотонных булевых в работе \cite{bin_mon}.

%В данной работе эта задача решается для класса линейных k-значных функций 
%при \(k = 3\) и \(k = 5\).

%-------------------------------постановка----------------------------------------

  \chapter{Постановка задачи}
  
Разработка и реализация алгоритма, получающего, в случае их существования, универсальные функции 
двух переменных для класса линейных \(k\)-значных при составных \(k\). Результатом работы являются таблицы 
функций, а также обоснование корректности работы алгоритма.
  
Рассматривались значения \(k = 4, 6, 8, 9, 10\).

%-------------------------------основная часть-----------------------------------------
\chapter{Описание основных этапов работы программы}

Для поиска универсальных функций был использован алгоритм, описанных в работе \cite{}.

\section{Создание матрицы}

По заданному значению \(k\) строится булева матрица \(A\), столбцам которой соответствуют всевозможные пары различных линейных 
функций двух переменных \(k\)-значной логики, а строкам -- тройки \((x_1, x_2, y), 0 \geq x_i < k, 0 \geq y < k\), 
где \((x_1, x_2)\) -- набор, на котором определяется универсальная функция, а \(y\) -- возможное значение на этом наборе.

\(A[i][j] = true\) тогда и только тогда, когда для пары \((f(x_1, x_2), g(x_1, x_2))\), соответствующей столбцу \(j\), и тройки 
\((x_1, x_2, y)\), соответствующей строке \(i\), выполнено \[f(x_1, x_2) = y \neq g(x_1, x_2)\].

Основной функцией построения матрицы является

\begin{lstlisting}
std::vector<std::vector<bool>> gen_matrix(int k);
\end{lstlisting}

Структура для хранения троек \((x_1, x_2, y)\), соответствующих строкам матрицы
\begin{lstlisting}
struct point
{
  int x_1, x_2;
  int y;
};
\end{lstlisting}

Структуры для хранения пар функций, соответствующих столбцам матрицы
\begin{lstlisting}
struct lin_function
{
  int a_0, a_1, a_2;
};


struct pair_of_lin
{
  lin_function f, g;
};
\end{lstlisting}




\section{Построение покрытия матрицы}

Для полученной матрицы строится градиентное покрытие следующим образом:
\begin{enumerate}
\item Пока есть неиспользованные строки и непокрытые столбцы
\begin{compactlist}
\item Выбирается строка \(s_i = (x_1, x_2, y)\) с наибольшим количеством единиц, находящихся в непокрытых столбцах.
\item Строка \(s_i\) добавляется в покрытие, все столбцы, покрытые ею, отмечаются.
\item Все строки вида \((x_1, x_2, y')\), где \(y \neq y'\), отмечаются как использованные, но не добавляются в покрытие.
\end{compactlist}
\item Если все столбцы покрыты, то полученное покрытие задаёт универсальную функцию.
\end{enumerate}

Основной функцией построения покрытия матрицы является

\begin{lstlisting}
std::vector<int> grad_algo(std::vector<std::vector<bool>> matrix, int k);
\end{lstlisting}

В случае, если покрытие было найдено, функция возвращает список номеров строк, являющихся покрытием. 
Иначе возвращает пустой список.

\section{Модификация построения покрытия}

До начала работы алгоритма градиентного покрытия задаётся некоторый набор значений возможной универсальной функции: 
\[F(0, t) = F(t, 0) = 0, F(t, k-1) = F(k-1, t) = t, F(1, t) = -t\]
Соответствующие строки добавляются в покрытие, столбцы, покрытые этими строками, отмечаются покрытыми, 
строки, противоречащие этим значениям, отмечаются как использованые.
После этого на получившейся матрице запускается описанный выше алгоритм покрытия.

Основной функцией этой модификации является

\begin{lstlisting}
std::vector<int> grad_algo_with_mod(std::vector<std::vector<bool>> matrix, int k, std::vector<point> mods);
\end{lstlisting}

где 
\begin{lstlisting} 
std::vector<point> mods 
\end{lstlisting} 
-- список точек, в которых функция задана заранее.

\section{Построение универсальной функции по покрытию}

В случае, если покрытие удалось построить, по покрытию строится универсальная функция. Из значений номеров строк, входящих в 
покрытие, вычисляются тройки \((x_1, x_2, y)\), а по ним -- таблица значений универсальной функции.

Основной функцией этого этапа является

\begin{lstlisting}
std::vector<std::vector<int>> get_univ_function_by_coverage(int k, std::vector<int> list_of_strings);
\end{lstlisting}


\chapter{Результаты работы}

Для значений \(k = 4\) и \(k = 6\) с помощью данного алгоритма не было получено универсальных функций.

Для значений \(k = 8\), \(k = 9\) и \(k = 10\) были получены универсальные функции, представленные ниже 
в таблицах 1, 2 и 3 соотвественно.

\centerline{\bf Таблица 1.}
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
\hline \(x\) & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\ \hline
0 & 0 & 0 & 1 & 1 & 2 & 2 & 3 & 3 \\ \hline 
1 & 0 & 5 & 1 & 6 & 2 & 7 & 3 & 4 \\ \hline
2 & 1 & 2 & 2 & 1 & 2 & 3 & 6 & 4 \\ \hline
3 & 2 & 3 & 3 & 1 & 3 & 4 & - & - \\ \hline
4 & 3 & 6 & 0 & 3 & 5 & 0 & - & - \\ \hline
5 & 1 & 4 & 4 & 3 & - & 2 & 7 & 1 \\ \hline
6 & 4 & 7 & - & 7 & 3 & - & 0 & 0 \\ \hline
7 & - & 2 & 4 & - & 5 & 1 & 0 & - \\ \hline
\end{tabular}
\end{center}

\centerline{\bf Таблица 2.}
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|}
\hline \(x\) & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 \\ \hline
0 & 0 & 0 & 0 & 1 & 1 & 2 & 2 & 2 & 1 \\ \hline 
1 & 8 & 1 & 7 & 4 & 2 & 5 & 6 & 0 & 6 \\ \hline
2 & 8 & 0 & - & 7 & - & 7 & - & 7 & 3 \\ \hline
3 & 0 & 3 & 4 & 1 & - & 8 & - & 8 & 5 \\ \hline
4 & 8 & 8 & 4 & - & 7 & 7 & 4 & 3 & 1 \\ \hline
5 & 2 & 4 & 1 & - & - & - & - & 6 & 3 \\ \hline
6 & - & 8 & 6 & 5 & - & 7 & 5 & 1 & 0 \\ \hline
7 & 0 & 7 & 6 & - & 7 & 8 & - & 6 & 6 \\ \hline
8 & 0 & - & - & - & 8 & - & - & - & - \\ \hline
\end{tabular}
\end{center}


\centerline{\bf Таблица 3.}
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|}
\hline \(x\) & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 \\ \hline
0 & 0 & 4 & 1 & 5 & 8 & 1 & 7 & 0 & 8 & 9 \\ \hline 
1 & 0 & 0 & 0 & 9 & - & 7 & 1 & 0 & 0 & 0 \\ \hline 
2 & 1 & 1 & 6 & 4 & 2 & 4 & 5 & 0 & - & - \\ \hline 
3 & 6 & 5 & 1 & 4 & - & 0 & - & 1 & - & 1 \\ \hline 
4 & 4 & 5 & 8 & - & - & - & 3 & 0 & - & 7 \\ \hline 
5 & 2 & 6 & 3 & 8 & 0 & 3 & 3 & 2 & 1 & 7 \\ \hline 
6 & 1 & 8 & 6 & - & - & - & 1 & 3 & - & - \\ \hline 
7 & 8 & - & - & - & 1 & 2 & 7 & - & 0 & 9 \\ \hline 
8 & 8 & - & - & - & - & 9 & 9 & 0 & - & - \\ \hline 
9 & 1 & - & - & - & - & 5 & 1 & 6 & - & - \\ \hline 
\end{tabular}
\end{center}


%----------------------------СПИСОК ЛИТЕРАТУРЫ
\begin{thebibliography}{0}

\bibitem{bin_lin} Вороненко А.А. \emph{Об универсальных частичных функциях для класса линейных функций}. 
Дискретная математика, том 24, № 3, с. 62-65.
 
\bibitem{k_lin} Вороненко А.А. \emph{О порождении ложных образов линейных k-значных функций}. 
Прикладная математика и информатика, том 48, в печати.

\bibitem{bin_mon} Вороненко А.А., Федорова В.С. \emph{О порождении ложных образов линейных k-значных функций}.
Вестник Московского университета. Серия 15. Вычислительная математика и кибернетика, № 1, с. 46-47.

\end{thebibliography}
\end{document}
